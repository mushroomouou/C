# 绪论
## 数据结构的定义：
### 数据结构中的几个概念：
* 数据：所有能够输入到计算机中的，且能够被计算机处理的符号集合。(world,balabala,结构化数据)
* 数据元素：是数据(集合)中的一个"个体"，它是数据的基本单位。
* 数据项：数据项是用来描述元素的，它是数据的最小单位。
* 数据对象：具有*相同性质*的若干个数据元素的集合，如整数数据的对象就是所有整数的集合。
> 默认情况下，数据结构中讨论的数据都是数据对象。
* 数据结构：是指带有结构的数据元素的集合。
` 数据结构 = 数据对象 + 结构`
而这里结构是指数据*元素之间的关系[1]*构成的结构。
#### 数据结构的构成：
> 一个数据结构主要由逻辑结构，存储结构，数据运算所构成，。
* 数据元素之间的逻辑关系-> 数据的逻辑结构。
* 数据元素及其关系在计算机储存器(RAM)中的存储方式->数据的存储结构(或者物理结构)。
* 施加在该数据之上的操作->数据运算。
### 1.数据的逻辑结构的表示：
> 数据的逻辑结构是面向用户的，它具有多种表现形式。
`逻辑结构可以使用表格来表示，二元组，图形`

![二元表](D:\C\数据结构\pictures\U_O{I99VNUYEWHIIC@CDIV3.png)

每个关系都可以使用若干个序偶来表示：
* 序偶<x,y> (x,y属于D) -> x为第一元素，y为第二元素
* x为y的前趋元素。
* y为x的后继元素。
* 如果某个元素没有前趋元素，则称该元素为开始元素，如果某个元素没有后继元素则称这个元素为终端元素。
* 用尖括号表示有方向，没有尖括号表示无方向。
  
### 数据的存储结构的表示
> 数据在计算机储存器中的储存方式就是存储结构，它是面向程序员的。`逻辑结构映射到储存结构`
* 设计储存结构的这种映射应该满足一下这两个要求：
* 存储所有的元素
* 储存数据元素间的关系。
##### 顺序存储结构(数组结构)：
* 这种存储结构的特点：
* 所有元素都占用一块内存空间，
* 逻辑上相邻的元素，物理上也是相邻的。
##### 链式存储结构：
* 一个逻辑元素用一个节点存储，每个节点存储，每个节点需要单独分配，所有的节点地址不一定是连续的。
* 用指针来表示逻辑关系。
### 数据运算：
> 数据运算是对数据的操作。分为两个层次：*运算描述*和*运算实现*。
结论：
* 同一个逻辑结构可以对应多个存储结构。
* 同样的运算，在不同的存储结构中的实现过程并不相同，也就是说算法不相同。

## 逻辑结构类型：
### 1.集合：
> 元素之间的关系：无
> 特点：数据元素之间除了“属于同一个集合”的关系外，别无其他逻辑关系。是松散的，不受任何制约的关系。
### 2.线性结构：
> 元素之间的关系：一对一
> 特点：开始元素和终端元素都是唯一的，除此之外，其余元素都有且仅有一个前趋元素和一个后继元素。
### 3.树形结构：
> 元素之间关系：一对多。
> 特点：可以元素唯一，终端元素不唯一。除终端元素以外，每个元素有一个或者多个后继元素，除开始元素外，每个元素有且仅有一个前趋元素。
### 4.图形结构：
> 元素之间的关系：多对多。
> 特点：所有元素都可能有多个趋势元素，和多个后继元素。

## 存储结构类型：
> 在软件开发中有多种存储结构。归纳为4种基本存储结构：
* 顺序存储结构
* 链式存储结构
* 索引存储结构
* 哈希(散列)存储结构

## 数据类型和抽象数据类型
### 1.数据类型
> 在高级程序语言中提供了多种数据类型。不同的数据类型的变量，其可能所取的值不一定相同。所能进行的操作也不一定相同。
> `数据类型`是一个值的集合和定义在此集合上的一组操作的总称。
> 数据类型和数据结构的关系：数据类型就是*已经实现*了的数据结构。
### 2.抽象数据类型：
> 抽象数据类型(ADT)指的是从求解问题的数学模型中抽象出来的数据逻辑结构和运算(抽象运算)，而不去考虑计算机的具体实现。
> `抽象数据类型 = 逻辑结构 + 抽象运算`

## 算法及其描述：
### 什么是算法：
> 数据元素之间的关系有逻辑关系和物理关系，对应的原酸又基于逻辑结构的运算描述和基于存储结构的运算实现。
> 通常把基于存储结构的运算实现的步骤或者过程称之为算法。
### 算法的五个重要特性：
> (1) 有穷性：在有穷步之后结束，算法能够停机。
> (2) 确定性：无二义性。
> (3) 可行性：可以通过基本运算有限次执行来实现，也就是说算法中的每一个动作都能被机械的执行。
> (4) 有输入
> (5) 有输出 这最后两个表示存在数据的处理。

### 算法描述
* 输入到算法里面算法描述的一般格式为，
```c++
void functionname(int number, char ch)
{
    //临时变量的定义
    //实现由输入参数到输出参数的操作
    //。。。
}
```
* 返回值通常为bool类型的，表示算法是否成功执行。
* 形参列表：由输入型参数和输出型参数构成。其中输入型参数是由算法输入的，输出型参数是通过算法输出的。

## 算法分析基础
> 分析算法占用的资源有以下两个方面，1.CPU时间是指的是时间性能的分析，2.内存空间，是指的是空间性能。`算法分析的目的`:分析算法的时空效率以便改进算法。
### 算法时间复杂度的分析：
> 一个算法是由控制结构(顺序，分支，和循环三种所构成)和原操作(指固有数据类型的操作，比如说+-*/++。。。)构成的。算法执行的时间基于这二者的综合效果。就一个算法是由控制语句加上原操作的加和这样构成的一个集合体具有一定的能力去实现我们需要的核心算法。

#### 算法分析方法：
* 1.事后分析统计方法:编写算法对应的程序，统计其执行的时间。
        编写程序的语言不同(!!!)
        执行程序的环境不同(!!!Linux!!!)
        其他因素
* 由于以上三者的影响，不能用绝对执行时间来比较。
* 2.事前估算分析方法:撇开上述因素，认为算法执行的时间就是问题规模n的函数。
    * 分析算法执行的时间：
        * 1.求出算法所有原操作的执行次数(也称为*频度*)，它是问题规模为n的函数。用T(n)表示。
        * 
        * 2.算法执行的时间大致=原操作所需的时间XT(n).所以T(n)与算法执行的时间成正比。为此用T(n)表示算法执行的时间。
        * 3.比较不同的算法的T(n)大小得出算法执行的时间的好坏。
            * 算法执行的时间使用时间复杂度来表示：
              *  算法执行时间T(n)是问题规模n的某个函数f(n)，记作：
                        T(n) = O(f(n))
                    记号“O”读作“大O”，它表示随着问题规模n的增大算法执行的使劲按的增长率和f(n)的增长率相同。这也就是趋势分析。`这里的大O表示n趋近于无穷大时，T(n)/f(n) = M,也就是趋近于极限，且极限存在。`
                一般的：
                * 当没有循环语句时我们称这个执行时间与问题规模无关，记作O(1)
                * 一个只有一重循环的算法的执行的时间与问题规模n的增长呈现线性增长关系，记作O(n)，也叫做*线性阶*。
                * 其余的算法时间复杂度还有平方阶O(n^2),立方阶O(n^3),还有啥对数阶，对数阶。
                    O(1) < O(log) < O(n) < O(nlog) < O(n^2) < O(2^n) < O(n!)
                    *前面的我们成为多项式阶问题P问题，后面为指数阶NP问题*
                    我们按照上面对每一个算法的时间复杂度分析可知道算法的优劣
                    可以大致按照最低层的原操作乘以循环次数表示时间复杂度。
    * 算法空间复杂度的分析：
        * 空间复杂度：
        > 用于量度一个算法在运行的过程中临时所占用的储存空间的大小。
          * 一般可以记作S(n) = O(g(n))
          * 如果说一个算法的空间复杂度为O(1)的话我们称此算法为原地工作算法或者就地工作算法。
          * 只考虑算法的临时存储空间作为其空间复杂度。



[1]:主要讨论的的是数据与数据之间的相邻关系，与邻接关系。
