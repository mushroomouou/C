### 全局变量：
> 定义在函数外面的变量就是全局变量。  
* 全局变量具有全局的生存期和作用域。
		它们与任何函数都无关。
		在任何函数的内部都可以使用他们。
		__func__ 表示当前的函数的名字。
		全局变量与任何函数无关，可以是任意的去访问。
* 全局变量初始化：
		没有做初始话的全局变量会得到0值。
		指针会得到NULL也就是指空了;
		只能用编译时刻<已知的值><别整些华丽胡哨的。>来初始花全局变量。
		它们的初始话发生在main函数之前。
* 被隐藏的全局变量：
>如果函数内部存在与与全局变量同名的变量，则全局变量会被隐藏。
* 静态全局变量：
> 在本地变量的定义时加上<static>修饰符就会成为静态本地变量;
> 当函数离开时，静态本地变量就会继续存在并保持其值。
> 静态本地变量的初始化只会在第一次进入这个函数的时候做，以后进入函数时会保持上次离开的值。
> 其实静态本地变量就是全局变量！！！！！一次赋值，以后就能一直访问，什么叫做全局变量，就是在程序的任何位置都能够去访问，而且地址被所有人所熟知。
> 静态本地变量与全局变量位于相同的内存区域，其具有全局的生存期，本地作用域，什么意思呢。函数内的全局变量。只在函数里面调用。


### 返回指针的函数：
* 返回本地变量的地址是危险的。函数访问结束后我们就会把那个地址给别人，会出大问题的。
* 返回全局变量，静态本地变量的地址是安全的。
* 返回在函数内部malloc的内存是安全的，但是容易造成问题。
* 最好的方法就是返回传入的指针。

### 编译预处理和宏：
* #开头的就是编译预处理指令;
* 它们并不是C语言成分的一部分，但是C语言的运行离不开他们;
* #define用来定义一个宏;例如#define PI 3.14159这个就是定义了一个定量。原始文本替换。
		第一是单词后面都是内容，并且可以在define间嵌套。
		\这个表示还没有结束。
#### 预定义的宏：
__FUNC__这样的就是宏;
#### 像函数的宏：
* #define cube(x) ((x)*(x)*(x))
* 宏可以携带参数
##### 错误定义的宏：
* #define RADTODEG(x) (x * 57.29578)
> 使用 gcc balabala.c --save-tamps
* 所有都需要参数。
###### 带参数的函数;
* 宏在大型程序的代码中使用的非常普遍
* 但是不存在检查;
* 部分函数如inline可以取代一部分的宏。
### 大程序结构：
#### 多个.c 文件:
> main()里面的代码太长了适合分成几个函数。
> 一个源代码文件太长了适合分成几个文件。
> 两个独立的源代码文件不能编译形成可执行的程序。
#### 头文件：
* 把函数原型放到一个头文件.h中，还需要调用这个函数的源代码文件 （。c）中#include这个头文件能够让编译器在编译的时候知道函数在哪儿。知道这个函数的原型。
* #include有两种形式来指出要插入的数据;
* ""这个要求编译器首先在本地寻找这个文件，如果没有，到编译器制定的目录去找。
* <>让编译器只在制定的目录下面去找。
* 编译器自己知道标准库的头文件在哪里。
* 环境变量和编译器命令行参数也可以制定寻找头文件的目录。
#### 全局变量的使用：
* 让别的程序使用另一个程序的变量：使用extern语句修饰，其意思就是说让程序知道有一个东西在整个项目里面，你得去找。
* 变量的声明： int i 事变量的定义 而extern int i是对变量的声明。
##### 声明与定义的区别：
* 	声明是只不产生代码的东西，如函数原型，变量声明，。。。而定义是产生代码的东西，也就是这一步对整个程序有作用。
* 关于套娃，dame不能行的，一旦程序躲起来就容易出现重复，但还是解决办法
		#ifndef _MAX_H
		#define _max_H
		
	
		如果没有定义过就定义！！！！
		#endif
		这样就能够可以避免在主程序引用时，避免由于重复定义而造成的错误。

* 编译器会帮你查看是否重复过！！！！














